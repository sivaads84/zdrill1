const path = require('path');

const AddHandler = require('./add');
const Constants = require('../constants');
const i18n = require('../i18n/i18n');
const MTAHelper = require('../helper/mta_helper');
const NpmDependenciesHelper = require('../helper/npm_dependencies_helper');



class AddDbHandler extends AddHandler {
    constructor(addCommand) {
        super(addCommand);
    }

    async stageCopyTemplates(moduleFolder, options) {
        this._command.reportProgress(i18n.t(i18n.add_copying_templates, { moduleFolder, moduleType: Constants.MODULE_TYPE_DB }), options.verbose);

        const modulePath = path.join(options.projectRoot, moduleFolder);
        await this.fsHelper.mkdirp(modulePath);
        if (options.dbTechnology === Constants.DB_TECHNOLOGY_HANA) {
            await this.fsHelper.copyTemplate('db/hana', modulePath, options);
        }
    }

    async copySamples(moduleFolder, options) {
        const modulePath = path.join(options.projectRoot, moduleFolder);
        await this.fsHelper.copyTemplate('db/samples', modulePath, {});
    }

    async stagePostProcessing(moduleFolder, options) {
        const yamlPath = path.join(options.projectRoot, 'mta.yaml');
        if (await this.fsHelper.pathExists(yamlPath)) {
            this._command.reportProgress(i18n.t(i18n.init_creating_mta_file, { yamlPath }), options.verbose);
            await MTAHelper.update(
                moduleFolder,
                yamlPath,
                Constants.MODULE_TYPE_DB,
                options,
                this.fsHelper,
                this.logger
            );
        }

        await this._extendGlobalPackageJson(moduleFolder, options);
        await this.extendCdsrcJson(moduleFolder, Constants.TASKS[Constants.MODULE_TYPE_DB][options.dbTechnology], options);
    }

    async _extendGlobalPackageJsonHana(packageJson, options) {
        packageJson.dependencies = packageJson.dependencies || {};
        packageJson.dependencies[Constants.SAP_HANA_CLIENT] = NpmDependenciesHelper.REPLACE_TOKEN;

        const newDependencies = await NpmDependenciesHelper.updateDependencies(packageJson.dependencies, options,this.logger);
        packageJson.dependencies = newDependencies;

        packageJson.cds = packageJson.cds || {};
        packageJson.cds.requires = packageJson.cds.requires || {};

        packageJson.cds.requires[Constants.PRIMARY_DB] = packageJson.cds.requires[Constants.PRIMARY_DB] || {};
        packageJson.cds.requires[Constants.PRIMARY_DB].kind = Constants.DB_TECHNOLOGY_HANA;
        packageJson.cds.requires[Constants.PRIMARY_DB].model = this.getModelFolders(options);
    }

    async _extendGlobalPackageJsonSqlite(packageJson, options) {
        packageJson.devDependencies = packageJson.devDependencies || {};
        packageJson.devDependencies.sqlite3 = NpmDependenciesHelper.REPLACE_TOKEN;

        const newDevDependencies = await NpmDependenciesHelper.updateDependencies(packageJson.devDependencies, options,this.logger);
        packageJson.devDependencies = newDevDependencies;

        packageJson.cds = packageJson.cds || {};
        packageJson.cds.requires = packageJson.cds.requires || {};

        packageJson.cds.requires[Constants.PRIMARY_DB] = packageJson.cds.requires[Constants.PRIMARY_DB] || {};
        packageJson.cds.requires[Constants.PRIMARY_DB].kind = Constants.DB_TECHNOLOGY_SQLITE;
        packageJson.cds.requires[Constants.PRIMARY_DB].model = this.getModelFolders(options);

        packageJson.cds.requires[Constants.PRIMARY_DB].credentials = {
            database: `${options.projectName}.db`
        };
    }

    getModelFolders(options) {
        const result = new Set();
        for (var moduleType in options.modules) {
            result.add(options.modules[moduleType].folder.trim());
        }
        return [...result];
    }

    async _extendGlobalPackageJson(moduleFolder, options) { //NOSONAR
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);

        if (await this.fsHelper.pathExists(packageJsonPath)) {
            const packageJson = await this.fsHelper.readJSON(packageJsonPath);

            let packageJsonChanged = false;

            switch (options.dbTechnology) {
                case Constants.DB_TECHNOLOGY_HANA:
                    await this._extendGlobalPackageJsonHana(packageJson, options);
                    packageJsonChanged = true;
                    break;

                case Constants.DB_TECHNOLOGY_SQLITE:
                    await this._extendGlobalPackageJsonSqlite(packageJson, options);
                    packageJsonChanged = true;
                    break;

                default:
                    break;
            }

            packageJson.files = packageJson.files || [];
            if (!packageJson.files.includes(moduleFolder)) {
                packageJson.files.push(moduleFolder);
                packageJsonChanged = true;
            }

            if (moduleFolder !== Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_DB]) {
                this.updatePackageJsonModelFolder(packageJson, moduleFolder, Constants.MODULE_TYPE_DB);
                packageJsonChanged = true;
            }

            if (packageJsonChanged) {
                await this.fsHelper.writeJSON(packageJsonPath, packageJson);
            }
        }
    }
}

module.exports = AddDbHandler;
