const path = require('path');

const AddHandler = require('./add');
const Constants = require('../constants');
const ExecHelper = require('../helper/exec_helper');
const i18n = require('../i18n/i18n');
const MTAHelper = require('../helper/mta_helper');
const MvnArchetypes = require('../java/mvn_archetypes');
const XmlHelper = require('../helper/xml_helper');



class AddSrvHandler extends AddHandler {
    constructor(addCommand) {
        super(addCommand);
    }

    async checkPrecondition(moduleFolder, options) {
        await super.checkPrecondition(moduleFolder, options);

        let projectOdataVersion = Constants.DEFAULT_ODATA_VERSION;
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);
        if (await this.fsHelper.pathExists(packageJsonPath)) {
            const packageJson = await this.fsHelper.readJSON(packageJsonPath);

            if (packageJson.cds && packageJson.cds.odata) {
                projectOdataVersion = packageJson.cds.odata.version || projectOdataVersion;
            }

            if (projectOdataVersion !== options.odataVersion) {
                this._command.reportWarning(i18n.t(i18n.add_different_odata_version, {
                    odataVersion: projectOdataVersion,
                    newVersion: options.odataVersion
                }), !options.quiet);
            }
        }

        projectOdataVersion = options.odataVersion || projectOdataVersion;
        if (options.modules && options.modules[Constants.MODULE_TYPE_SRV]) {
            if (options.srvTechnology === Constants.SRV_TECHNOLOGY_NODEJS && projectOdataVersion !== Constants.ODATA_VERSION_V4) {
                this._command.reportWarning(i18n.wrong_odata_version_for_nodejs, options.debug);
                options.odataVersion = 'odatav4';
            }
        }
    }

    async stageCopyTemplates(moduleFolder, options) {
        this._command.reportProgress(
            i18n.t(i18n.add_copying_templates, { moduleFolder: moduleFolder, moduleType: Constants.MODULE_TYPE_SRV }), options.verbose
        );

        const modulePath = path.join(options.projectRoot, moduleFolder);
        await this.fsHelper.mkdirp(modulePath);

        switch (options.srvTechnology) {
            case Constants.SRV_TECHNOLOGY_JAVA:
                break;

            case Constants.SRV_TECHNOLOGY_NODEJS:
                if (this._command.isWebIDE()) {
                    await this.fsHelper.copyTemplate('srv/nodejs/common', modulePath, options);
                }
                break;

            default:
                throw new Error(`Invalid srv technology: ${options.srvTechnology} `);
        }
    }

    async copySamples(moduleFolder, options) {

        const dbModule = options.modules[Constants.MODULE_TYPE_DB];

        const modulePath = path.join(options.projectRoot, moduleFolder);
        let relativeDbFolder = path.relative(moduleFolder, dbModule.folder);

        // remove windows back slashes
        relativeDbFolder = relativeDbFolder.replace(/\\/g, '/');
        await this.fsHelper.copyTemplate('srv/samples', modulePath, { dbModuleFolder: relativeDbFolder });

        if (options.srvTechnology === Constants.SRV_TECHNOLOGY_JAVA) {
            const packagePath = options.javaPackage.split('.');
            const javaSrcPath = path.join(modulePath, 'src', 'main', 'java', ...packagePath);

            await this.fsHelper.copyTemplate('srv/java/samples', javaSrcPath, options);
        }
    }

    async stagePostProcessing(moduleFolder, options) {

        switch (options.srvTechnology) {
            case Constants.SRV_TECHNOLOGY_JAVA:
                this._command.reportProgress(i18n.init_creating_java_srv, options.verbose);

                await this._runMvn(moduleFolder, options);

                this._command.reportProgress(
                    i18n.init_postprocessing_java_srv,
                    options.verbose
                );

                await this._patchPomXml(path.join(options.projectRoot, moduleFolder, 'pom.xml'));
                break;

            case Constants.SRV_TECHNOLOGY_NODEJS:
                await this._command.updateDependencies(path.join(options.projectRoot, moduleFolder, Constants.FILE_NAME_PACKAGE_JSON), options, this.logger);
                await this._extendLocalPackageJson(moduleFolder, options);
                break;

            default:
                throw new Error(`Invalid srv technology: ${options.srvTechnology} `);
        }

        const yamlPath = path.join(options.projectRoot, 'mta.yaml');
        if (await this.fsHelper.pathExists(yamlPath)) {
            this._command.reportProgress(i18n.t(i18n.init_creating_mta_file, { yamlPath }), options.verbose);
            await MTAHelper.update(
                moduleFolder,
                yamlPath,
                Constants.MODULE_TYPE_SRV,
                options,
                this.fsHelper,
                this.logger
            );
        }

        await this._extendGlobalPackageJson(moduleFolder, options);
        await this.extendCdsrcJson(moduleFolder, Constants.TASKS[Constants.MODULE_TYPE_SRV][options.srvTechnology], options);
    }

    async _runMvn(moduleFolder, options) {
        const modulePath = path.join(options.projectRoot, moduleFolder);
        let tempFolder;
        try {
            tempFolder = await this.fsHelper.createTempFolder('cds-gen-');
            const odataArchetypeCommand = MvnArchetypes.odataArchetypeCommand(
                moduleFolder,
                options.javaPackage,
                options.projectName,
                options.odataVersion,
                options.quiet,
                options.debug
            );

            await ExecHelper.spawnCommand(
                odataArchetypeCommand,
                tempFolder,
                options,
                this.logger
            );

            const mavenResultPath = path.join(tempFolder, `${options.projectName}-${moduleFolder}`);

            await this.fsHelper.copy(mavenResultPath, modulePath);
        } finally {
            await this.fsHelper.removeTempFolder(tempFolder);
        }
    }

    async _patchPomXml(pomXmlPath) {
        if (await this.fsHelper.pathExists(pomXmlPath)) {
            const pomXml = await this.fsHelper.readFile(pomXmlPath);

            const pom = await XmlHelper.parse(pomXml);

            const pomPatchPluginXml = await this.fsHelper.readFile(
                this.fsHelper.getTemplate('srv/java/patch/pom.plugin.xml')
            );
            const pomPatchPlugin = await XmlHelper.parse(pomPatchPluginXml);

            if (!pom.project.build) {
                pom.project.build = [{}];
            }
            pom.project.build[0].plugins = pomPatchPlugin;


            const pomPatchResourceXml = await this.fsHelper.readFile(
                this.fsHelper.getTemplate('srv/java/patch/pom.resource.xml')
            );
            const pomPatchResource = await XmlHelper.parse(pomPatchResourceXml);
            pom.project.build[0].resources = pomPatchResource;


            const pomPatchPluginManagementXml = await this.fsHelper.readFile(
                this.fsHelper.getTemplate('srv/java/patch/pom.pluginManagement.xml')
            );
            const pomPatchPluginManagement = await XmlHelper.parse(pomPatchPluginManagementXml);
            pom.project.build[0].pluginManagement = pomPatchPluginManagement;


            const pomPatchPropertiesXml = await this.fsHelper.readFile(
                this.fsHelper.getTemplate('srv/java/patch/pom.properties.xml')
            );
            const pomPatchProperties = await XmlHelper.parse(pomPatchPropertiesXml);
            pom.project.properties[0] = {
                ...pom.project.properties[0],
                ...pomPatchProperties.project.properties[0]
            }

            const pomPatchProfilesXml = await this.fsHelper.readFile(
                this.fsHelper.getTemplate('srv/java/patch/pom.profiles.xml')
            );
            const pomPatchProfiles = await XmlHelper.parse(pomPatchProfilesXml);

            if (!pom.project.profiles) {
                pom.project.profiles = [{
                    profile: []
                }];
            }
            pom.project.profiles[0].profile = pom.project.profiles[0].profile.concat(pomPatchProfiles.profiles.profile);


            await this.fsHelper.writeFile(pomXmlPath, XmlHelper.stringify(pom));
        }
    }

    async _extendLocalPackageJson(moduleFolder, options) {
        const globalPackageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);

        if (await this.fsHelper.pathExists(globalPackageJsonPath)) {
            const globalPackageJson = await this.fsHelper.readJSON(globalPackageJsonPath);

            if (globalPackageJson.dependencies && globalPackageJson.dependencies[Constants.SAP_HANA_CLIENT]) {
                const localPackageJsonPath = path.join(options.projectRoot, moduleFolder, Constants.FILE_NAME_PACKAGE_JSON);
                if (await this.fsHelper.pathExists(localPackageJsonPath)) {
                    const localPackageJson = await this.fsHelper.readJSON(localPackageJsonPath);
                    localPackageJson.dependencies = localPackageJson.dependencies || {}
                    localPackageJson.dependencies[Constants.SAP_HANA_CLIENT] = globalPackageJson.dependencies[Constants.SAP_HANA_CLIENT];

                    await this.fsHelper.writeJSON(localPackageJsonPath, localPackageJson);
                }
            }
        }
    }

    async _extendGlobalPackageJson(moduleFolder, options) { //NOSONAR
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);

        if (await this.fsHelper.pathExists(packageJsonPath)) {
            const packageJson = await this.fsHelper.readJSON(packageJsonPath);

            let packageJsonChanged = false;

            packageJson.files = packageJson.files || [];
            if (!packageJson.files.includes(moduleFolder)) {
                packageJson.files.push(moduleFolder);

                packageJsonChanged = true;
            }

            packageJson.cds = packageJson.cds || {};

            if (options.modules && options.modules[Constants.MODULE_TYPE_SRV]) {
                let version;
                switch (options.srvTechnology) {
                    case Constants.SRV_TECHNOLOGY_JAVA:
                        version = options.odataVersion || Constants.DEFAULT_ODATA_VERSION;
                        break;

                    case Constants.SRV_TECHNOLOGY_NODEJS:
                        version = Constants.ODATA_VERSION_V4;
                        break;

                    default:
                        throw new Error(`Invalid srv technology: ${options.srvTechnology} `);
                }

                packageJson.cds.odata = {
                    version: version
                };

                packageJsonChanged = true;
            }

            if (moduleFolder !== Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_SRV]) {
                this.updatePackageJsonModelFolder(packageJson, moduleFolder,Constants.MODULE_TYPE_SRV);
                packageJsonChanged = true;
            }

            if (packageJsonChanged) {
                await this.fsHelper.writeJSON(packageJsonPath, packageJson);
            }
        }
    }
}

module.exports = AddSrvHandler;
