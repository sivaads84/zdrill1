const path = require('path');

const Constants = require('../constants');
const i18n = require('../i18n/i18n');



class AddHandler {
    constructor(command) {
        this._command = command;

        this.logger = command.logger;
        this.fsHelper = command.fsHelper;
    }

    // eslint-disable-next-line no-unused-vars
    async stageCopyTemplates(moduleFolder, options) { }

    // eslint-disable-next-line no-unused-vars
    async stagePostProcessing(moduleFolder, options) { }

    // eslint-disable-next-line no-unused-vars
    async copySamples(moduleFolder, options) { }

    async checkPrecondition(moduleFolder, options) {
        if (!options.force) {
            this._command.validateDestination(moduleFolder);
        }

        const modulePath = path.join(options.projectRoot, moduleFolder);
        if (await this.fsHelper.pathExists(modulePath)) {
            const folderContent = await this.fsHelper.readdir(modulePath);
            if (!options.force && folderContent.length > 0) {
                throw new Error(i18n.t(i18n.command_target_exists, { moduleFolder }));
            }
        }
    }

    async extendCdsrcJson(moduleFolder, buildTaskType, options) {

        const cdsrcJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_CDSRC_JSON);
        if (buildTaskType && await this.fsHelper.pathExists(cdsrcJsonPath)) {
            const cdsrcJson = await this.fsHelper.readJSON(cdsrcJsonPath);
            cdsrcJson.build = cdsrcJson.build || {};
            cdsrcJson.build.tasks = cdsrcJson.build.tasks || [];

            const optionsModel = [moduleFolder];
            const existingTasks = [];
            for (let task of cdsrcJson.build.tasks) {
                if (task.src !== moduleFolder) {
                    task.options = task.options || {};
                    task.options.model = task.options.model || [];
                    if (!task.options.model.includes(moduleFolder)) {
                        task.options.model.push(moduleFolder);
                    }
                    existingTasks.push(task);

                    optionsModel.push(task.src);
                }
            }

            existingTasks.push({
                for: buildTaskType,
                src: moduleFolder,
                options: {
                    model: optionsModel.sort()
                }
            });

            cdsrcJson.build.tasks = existingTasks;

            await this.fsHelper.writeJSON(cdsrcJsonPath, cdsrcJson);
        }
    }

    updatePackageJsonModelFolder(packageJson, moduleFolder, type) {
        packageJson.cds = packageJson.cds || {};
        packageJson.cds.folders = packageJson.cds.folders || {};

        const typeEntry = packageJson.cds.folders[type];
        if (!typeEntry) {
            packageJson.cds.folders[type] = moduleFolder;
        } else if (typeEntry instanceof String || typeof typeEntry === 'string') {
            packageJson.cds.folders[type] = [typeEntry, moduleFolder];
        } else if (Array.isArray(typeEntry)) {
            packageJson.cds.folders[type].push(moduleFolder);
        }
    }

}

module.exports = AddHandler;
