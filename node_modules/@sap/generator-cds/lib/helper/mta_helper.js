const path = require('path');
const YAML = require('yaml');

const Constants = require('../constants');
const i18n = require('../i18n/i18n');


class MTAHelper {

    static async update(moduleFolder, mtaPath, moduleType, options, fsHelper, logger) {

        // yaml.parse doesn't like null
        const yamlStr = await fsHelper.readFile(mtaPath) || '';

        // yaml returns null if string couldn't be parsed, e.g. empty string
        const mta = YAML.parse(yamlStr) || {};
        let fileChanged = false;

        switch (moduleType) {
            case Constants.MODULE_TYPE_APP:
                this._addAppModule(moduleFolder, mta, options.projectName, options.insecure, options.force);
                fileChanged = true;
                break;

            case Constants.MODULE_TYPE_DB:
                if (options.dbTechnology === Constants.DB_TECHNOLOGY_HANA) {
                    this._addDbModule(moduleFolder, mta, options.projectName);
                    this._addHdiContainerResource(moduleFolder, mta, options.projectName, options.force);
                    fileChanged = true;
                }
                break;

            case Constants.MODULE_TYPE_SRV: {
                this._addSrvModule(moduleFolder, mta, options.projectName, options.srvTechnology, options.srvMemory, options, logger);
                fileChanged = true;
                break;
            }

            default:
                // this is a programming error, so no translatable text
                throw new Error(`Module type '${moduleType}' not found`);

        }

        if (fileChanged) {
            await fsHelper.writeFile(mtaPath, YAML.stringify(mta));
        }
    }

    static _findInArray(array, property, value) {
        if (array) {
            return array.findIndex(element => {
                return element[property] === value;
            });
        }

        return -1;
    }

    static _filterArray(array, property, value) {
        if (array) {
            const index = this._findInArray(array, property, value);
            if (index > -1) {
                array.splice(index, 1);
            }

            return array;

        } else {
            return [];
        }
    }

    static _addSrvModule(folderName, mta, projectName, srvTechnology, srvMemory, options, logger) { //NOSONAR
        const folderSegments = folderName.split(/\//);
        const moduleName = `${projectName}-${folderSegments[0]}`;

        mta.modules = this._filterArray(mta.modules, 'name', moduleName);

        const srvModule = {
            name: moduleName,
            type: srvTechnology,
            path: folderName,
            parameters: {
                memory: srvMemory
            },
            provides: [{
                name: 'srv_api',
                properties: {
                    url: "${default-url}" //NOSONAR
                }
            }]
        };

        if (srvTechnology !== Constants.SRV_TECHNOLOGY_JAVA) {
            srvModule.parameters['disk-quota'] = '512M';
        }

        let hdiContainerName;
        const dbModule = options.modules && options.modules[Constants.MODULE_TYPE_DB];
        if (dbModule) {
            hdiContainerName = this._getHdiContainerName(dbModule.folder, projectName);
        } else {
            const hdiContainers = this._findHdiContainers(mta);
            if (hdiContainers.length > 0) {
                hdiContainerName = hdiContainers[0].name;
            }

            if (!options.quiet) {
                if (hdiContainers.length === 1) {
                    logger.log(i18n.t(i18n.init_using_only_hdi_container, {hdiContainerName, folderName}));
                }
                if (hdiContainers.length > 1) {
                    logger.log(i18n.t(i18n.init_using_first_hdi_container, {hdiContainerName, folderName}));
                }
            }
        }

        if (hdiContainerName) {
            srvModule.requires = srvModule.requires || [];
            this._addHdiRequires(srvModule.requires, hdiContainerName, srvTechnology === Constants.SRV_TECHNOLOGY_JAVA);
        }

        if (!options.insecure) {
            const uaaResourceName = this._addUaaResource(mta, projectName, options.force);
            srvModule.requires = srvModule.requires || [];
            srvModule.requires.push({
                name: uaaResourceName
            });
        }

        mta.modules.push(srvModule);
    }

    static _addHdiRequires(mtaRequires, name, addJBPConfig) {
        let requiresEntry = mtaRequires.find(entry => {
            return entry.name === name;
        });

        if (!requiresEntry) {
            requiresEntry = {};
            mtaRequires.push(requiresEntry);
        }

        requiresEntry.name = name;
        if (addJBPConfig) {
            requiresEntry.properties = {
                "JBP_CONFIG_RESOURCE_CONFIGURATION": "[tomcat/webapps/ROOT/META-INF/context.xml: {\"service_name_for_DefaultDB\" : \"~{hdi-container-name}\"}]"
           }
        }
    }

    static _findHdiContainers(mta) {
        if (mta && mta.resources) {
            return mta.resources.filter(resource => {
                return resource.type === Constants.HDI_CONTAINER_TYPE;
            });
        }

        return [];
    }

    static _addAppModule(folderName, mta, projectName, insecure, force) {
        const moduleName = `${projectName}-${folderName}`;

        mta.modules = this._filterArray(mta.modules, 'name', moduleName);

        const appModule = {
            name: moduleName,
            type: 'html5',
            path: `${path.basename(folderName)}`,
            parameters: {
                'memory': '256M',
                'disk-quota': '512M'
            },
            requires: [
                {
                    name: 'srv_api',
                    group: 'destinations',
                    properties: {
                        forwardAuthToken: true,
                        name: 'srv_api',
                        url: '~{url}'
                    }
                }
            ]
        };

        if (!insecure) {
            const uaaResourceName = this._addUaaResource(mta, projectName, force);
            appModule.requires.push({
                name: uaaResourceName
            });
        }

        mta.modules.push(appModule);
    }

    static _getHdiContainerName(dest, projectName) {
        dest = path.basename(dest);
        return `${projectName}-${dest}-hdi-container`;
    }

    static _addDbModule(folderName, mta, projectName) {
        const moduleName = `${projectName}-${folderName}`;

        mta.modules = this._filterArray(mta.modules, 'name', moduleName);
        const hdiContainerName = this._getHdiContainerName(folderName, projectName);

        const dbModule = {
            name: moduleName,
            type: 'hdb',
            path: folderName,
            parameters: {
                memory: '256M',
                'disk-quota': '512M'
            },
            requires: [
                { name: hdiContainerName }
            ]
        };

        const javaSrvModule = this._findJavaSrv(mta);
        if (javaSrvModule) {
            javaSrvModule.requires = javaSrvModule.requires || [];

            this._addHdiRequires(javaSrvModule.requires, hdiContainerName, true);
        }

        mta.modules.push(dbModule);
    }

    static _findJavaSrv(mta) {
        if (mta && mta.modules) {
            let javaSrvModule;
            const index = mta.modules.findIndex(mtaModule => {
                javaSrvModule = mtaModule;
                return mtaModule.type === Constants.SRV_TECHNOLOGY_JAVA && mtaModule.path === Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_SRV];
            });

            return (index > -1 ? javaSrvModule : null);
        }

        return null;
    }

    static _addUaaResource(mta, projectName, force) {
        mta.resources = mta.resources || [];

        let resourceName = `${projectName}-uaa`;
        let resource = {
            name: resourceName,
            type: Constants.RESOURCE_TYPE_MANAGED_SERVICE,
            parameters: {
                'service-plan': (process.env.DI_CORE_XSAPPNAME ? Constants.UAA_SERVICE_PLAN_DEFAULT : Constants.UAA_SERVICE_PLAN_APPLICATION),
                service: Constants.SERVICE_TYPE_XSUAA,
                config: {
                    xsappname: `${projectName}${(process.env.DI_CORE_XSAPPNAME ? '' : "-${space}")}`, //NOSONAR
                    'tenant-mode': 'dedicated'
                }
            }
        };

        // find existing resource, e.g. created by HTML5 module wizard
        const index = mta.resources.findIndex(element => {
            // scan for old and new type
            return element.type === Constants.RESOURCE_TYPE_UAA
                || (element.type === Constants.RESOURCE_TYPE_MANAGED_SERVICE
                    && element.parameters
                    && element.parameters.service === Constants.SERVICE_TYPE_XSUAA);
        });

        if (index < 0) {
            // not found -> add
            mta.resources.push(resource);
        } else {
            const oldResource = mta.resources[index];
            resourceName = oldResource.name;
            if (force) {
                // keep old name to not invalidate existing refs in mta.yaml
                resource.name = resourceName;
                mta.resources[index] = resource;
            }
        }

        // this might be different from project-uaa in case UAA resource existed with different name
        return resourceName;
    }


    static _addHdiContainerResource(dest, mta, projectName, force) {
        mta.resources = mta.resources || [];
        const resourceName = this._getHdiContainerName(dest, projectName);

        let resource = {};
        const index = this._findInArray(mta.resources, 'name', resourceName);
        if (index < 0) {
            mta.resources.push(resource);
        } else {
            resource = mta.resources[index];
            if (force) {
                this._wipeObject(resource);
            }
        }

        resource.name = resourceName;
        resource.type = Constants.HDI_CONTAINER_TYPE;
        resource.properties = {
            'hdi-container-name': "${service-name}" //NOSONAR
        };
    }

    static _wipeObject(obj) {
        for (let prop in obj) {
            delete obj[prop];
        }
    }
}

module.exports = MTAHelper;
