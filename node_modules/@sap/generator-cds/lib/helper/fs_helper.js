const { constants, promises: fsp } = require('fs');
const os = require('os');
const path = require('path');

const TEMPLATES_ROOT = path.join(__dirname, '..', 'templates');
const TEMPLATE_REGEX = /<%=\s*(\w+)\s*%>/g;

const TEMPLATE_EXTENSION = '.tpl';
const TEMPLATE_EXTENSION_REGEX = new RegExp(`${TEMPLATE_EXTENSION}$`);

const UTF_8 = 'utf-8';

const _touchedFiles = new Set();

class FsHelper {

    getTemplate(templatePath) {
        return path.join(TEMPLATES_ROOT, templatePath);
    }


    _addTouchedFile(filepath) {
        const relativeFilepath = path.relative('', filepath);
        _touchedFiles.add(relativeFilepath);
    }


    async writeFile(filepath, content, skipFileLog = false) {
        if (!skipFileLog) {
            this._addTouchedFile(filepath);
        }
        await fsp.mkdir(path.dirname(filepath), { recursive: true });
        await fsp.writeFile(filepath, content, UTF_8);
    }


    async writeJSON(filepath, object, options = { spaces: 4 }, skipFileLog = false) {
        const content = JSON.stringify(object, null, options.spaces);
        await this.writeFile(filepath, content, skipFileLog);
    }


    async readFile(src) {
        return fsp.readFile(src, UTF_8);
    }


    async readJSON(src) {
        const content = await this.readFile(src);
        return JSON.parse(content);
    }


    async copy(source, destination, options = {}) {

        const filter = options.filter;

        options.filter = async (src, dest) => {
            let result = true;
            if (filter) {
                result = filter(src, dest);
            }

            if (result) {
                const stats = await this.stat(src);
                if (stats.isFile()) {
                    this._addTouchedFile(dest);
                }
            }

            return result;
        };

        await this._copyFolder(source, destination, options);
    }


    _isTemplateFile(filename) {
        return path.extname(filename) === TEMPLATE_EXTENSION;
    }


    _filterFiles(src, destination, templateFiles) {
        const filename = path.basename(src);

        const isTemplateFile = this._isTemplateFile(filename);

        if (isTemplateFile) {
            templateFiles.push({ src: src, destination: destination });
        }

        return !isTemplateFile;
    }


    async copyTemplate(template, destinationPath, templateValues, overwrite = false) {
        const templatePath = this.getTemplate(template);
        const templateFiles = [];

        const fileFilter = (src, dest) => {
            return this._filterFiles(src, dest, templateFiles);
        }

        await this.copy(templatePath, destinationPath, {
            filter: fileFilter,
            overwrite: overwrite,
            errorOnExists: false
        });

        for (const templateFile of templateFiles) {
            await this._processTemplateFile(templateFile.src, templateFile.destination, templateValues, overwrite);
        }
    }


    async _processTemplateFile(src, destination, templateValues, overwrite = false) {

        const destinationPath = destination.replace(TEMPLATE_EXTENSION_REGEX, '');
        if (overwrite || !(await this.pathExists(destinationPath))) {
            let content = await this.readFile(src);
            content = this._replaceTemplatePlaceholder(content, templateValues);

            await this.writeFile(destinationPath, content);
        }
    }


    _replaceTemplatePlaceholder(content, templateValues) {

        // clone regex since we have to modify internals ...
        const regex = new RegExp(TEMPLATE_REGEX);
        let match = regex.exec(content);

        while (match !== null) {
            const value = templateValues[match[1]] || '';
            content = content.replace(match[0], value);

            // modify search index to start from beginning
            regex.lastIndex = 0;
            match = regex.exec(content);
        }

        return content;
    }


    async createTempFolder(preFix) {
        return fsp.mkdtemp(path.join(os.tmpdir(), preFix));
    }


    // extra method to indicate removeal without etra file handling (native remove)
    async removeTempFolder(tempFolder) {
        if (tempFolder) {
            await this.remove(tempFolder);
        }
    }


    async remove(src) {
        const stat = await this.stat(src);
        if (stat.isDirectory()) {
            if (typeof fsp.rm === 'function' ) {
                await fsp.rm(src, { recursive: true })
            } else {
                await fsp.rmdir(src, { recursive: true })
            }
        } else {
            await fsp.unlink(src);
        }
    }


    async pathExists(filePath) {
        try {
            await fsp.access(filePath, constants.R_OK | constants.W_OK);
            return true;
        } catch (err) {
            return false;
        }
    }


    async readdir(filePath) {
        return fsp.readdir(filePath);
    }


    getTouchedFiles() {
        return Array.from(_touchedFiles.keys());
    }


    async mkdirp(folderPath) {
        await fsp.mkdir(folderPath, { recursive: true });
    }


    async stat(filePath) {
        return fsp.stat(filePath);
    }

    async _copyFolder(src, dest, options = {}) {
        await fsp.mkdir(dest, { recursive: true });
        const files = await fsp.readdir(src, { withFileTypes: true });
        for (const file of files) {
            const srcPath = path.join(src, file.name);
            const destPath = path.join(dest, file.name);

            if (options.filter && !(await options.filter(srcPath, destPath))) {
                continue;
            }

            if (file.isDirectory()) {
                await this._copyFolder(srcPath, destPath);
            } else {
                await fsp.copyFile(srcPath, destPath);
            }
        }
    }

    // async _removeFolder(src) {
    //     const files = await fsp.readdir(src, { withFileTypes: true });
    //     for (const file of files) {
    //         const srcPath = path.join(src, file.name);
    //         if (file.isDirectory()) {
    //             await this._removeFolder(srcPath);
    //         } else {
    //             await fsp.unlink(srcPath);
    //         }
    //     }
    //     await fsp.rmdir(src);
    // }
}

module.exports = FsHelper;
