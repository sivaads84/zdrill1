const os = require('os');
const path = require('path');

const AddDbHandler = require('./handler/add_db');
const AddSrvHandler = require('./handler/add_srv');
const Command = require('./command');
const Constants = require('./constants');
const ExecHelper = require('./helper/exec_helper');
const { link } = require('./helper/term');
const i18n = require('./i18n/i18n');
const MvnArchetypes = require('./java/mvn_archetypes');
const XmlHelper = require('./helper/xml_helper');

const IS_WIN = (os.platform() === 'win32');

const ODATA_VERSION_MAP = {
    odatav2: Constants.ODATA_VERSION_V2,
    odatav4: Constants.ODATA_VERSION_V4
}
// keep short values
ODATA_VERSION_MAP[Constants.ODATA_VERSION_V2] = Constants.ODATA_VERSION_V2;
ODATA_VERSION_MAP[Constants.ODATA_VERSION_V4] = Constants.ODATA_VERSION_V4;

const CONFIG = Object.freeze({
    dbTechnology: {
        title: `Database Technology`,
        description: `Select the database technology. Can be one of [${[Constants.DB_TECHNOLOGY_HANA, Constants.DB_TECHNOLOGY_SQLITE].join(', ')}].`,
        default: Constants.DB_TECHNOLOGY_SQLITE,
        choices: [Constants.DB_TECHNOLOGY_HANA, Constants.DB_TECHNOLOGY_SQLITE],
        enabled: (answer) => {
            return answer.modules.includes(Constants.MODULE_TYPE_DB);
        },
        promptOrder: 10
    },
    insecure: {
        title: 'No UAA support',
        description: 'Skip creation of uaa entries.',
        default: false,
        promptOrder: 40
    },
    javaPackage: {
        title: 'Java Package Name',
        description: `The package ID for the java srv module.`,
        default: 'my.company',
        regex: Constants.REGEX_JAVA_PACKAGE,
        enabled: (answer) => {
            return answer.srvTechnology === Constants.SRV_TECHNOLOGY_JAVA;
        },
        promptOrder: 20
    },
    modules: {
        title: 'Module List',
        description: `List of the modules to be created.`,
        default: '',
        choices: [Constants.MODULE_TYPE_DB, Constants.MODULE_TYPE_SRV],
        multiple: true,
        promptOrder: 4
    },
    mta: {
        title: 'Create mta.yaml',
        description: `Create a project root level mta.yaml file.`,
        default: false,
        promptOrder: 35
    },
    odataVersion: {
        title: 'Odata Version',
        default: Constants.DEFAULT_ODATA_VERSION,
        regex: /(v2|v4|odatav2|odatav4)/, // allow long and short names
        description: `Generate odata support for givem version.`,
        choices: [Constants.ODATA_VERSION_V2, Constants.ODATA_VERSION_V4],
        promptOrder: 30
    },
    pipeline: {
        title: 'Add pipeline support',
        description: `Create files to add project to a pipeline.`,
        default: false,
        promptOrder: 38
    },
    skipInstall: {
        title: 'Do not run install',
        description: `Skip running npm install on created project.`,
        default: false,
        promptOrder: 100
    },
    skipSampleModels: {
        title: 'No Sample Models',
        description: `Skip creation of sample cds files.`,
        default: false,
        enabled: (answer) => {
            return answer.modules.includes(Constants.MODULE_TYPE_SRV) && answer.modules.includes(Constants.MODULE_TYPE_DB);
        },
        promptOrder: 50
    },
    srvMemory: {
        title: 'Service memory',
        description: `Amount of memory reserved for srv module.`,
        default: '512M',
        regex: Constants.REGEX_SRV_MEMORY,
        enabled: (answer) => {
            return answer.modules.includes(Constants.MODULE_TYPE_SRV);
        },
        promptOrder: 12
    },
    srvTechnology: {
        title: 'Srv Technology',
        description: `The technology to use for the srv module.`,
        default: Constants.SRV_TECHNOLOGY_NODEJS,
        choices: [Constants.SRV_TECHNOLOGY_JAVA, Constants.SRV_TECHNOLOGY_NODEJS],
        enabled: (answer) => {
            return answer.modules.includes(Constants.MODULE_TYPE_SRV);
        },
        promptOrder: 10
    }
});

class InitCommand extends Command {
    constructor(childConfig, logger, fsHelper) {
        super({ ...CONFIG, ...childConfig }, logger, fsHelper);
    }

    get options() {
        return this._options;
    }

    get help() {
        return i18n.init_help;
    }

    async run(args, options, cdsEnv) {
        await super.run(args, options, cdsEnv);

        if (cdsEnv && cdsEnv.cds_version) {
            this.logger.warn(`Internal parameter cds_version is no longer supported`);
        }

        this._options.projectRoot = path.resolve(this._options.destination);
        this._options.projectName = path.basename(this._options.projectRoot);

        if (this._options.pipeline) {
            this._options.mta = true;
        }

        // map long version names to short ones (internally used), use one mapping to avoid if/then/else blocks
        this._options.odataVersion = ODATA_VERSION_MAP[this._options.odataVersion];

        this._handleModules(this._options);

        await this.execute(this._options.projectRoot, this._options);

        await this.finalize();

        this.reportProgress(i18n.init_finished_successfully, !this._options.quiet);
        if (!this._options.quiet) {
            let url = 'https://go.sap.corp/cap/get-started/in-a-nutshell'
            if (!await this._pingUrl(url)) {
                url = 'https://cap.cloud.sap/docs/get-started/in-a-nutshell'
            }
            this.reportProgress(i18n.t(i18n.init_finished_successfully_url, { url: link(url) }), true);
        }
    }

    async _pingUrl(urlString) {
        const { URL } = require('url');
        const url = new URL(urlString)
        try {
            const args = ['ping'];
            if (IS_WIN) {
                args.push('-n 1');
            } else {
                args.push('-c 1')
            }
            args.push(url.host);
            await ExecHelper.executeCommand(args, this._options.projectRoot);
            return true;
        } catch (err) {
            return false;
        }

    }

    _handleModules(options) { // NOSONAR
        if (options.modules) {
            const modules = (typeof options.modules === 'string' ? options.modules.split(',') : options.modules);

            const newModules = {};
            for (let currentModule of modules) {
                const segments = currentModule.split(':');
                let moduleType;
                let moduleFolder;
                if (segments.length === 2) {
                    moduleType = segments[1];
                    moduleFolder = segments[0];

                    if (!options.force) {
                        this.validateDestination(moduleFolder);
                    }
                } else {
                    moduleType = currentModule;
                    moduleFolder = Constants.DEFAULT_MODULE_FOLDER[currentModule];
                }

                if (newModules[moduleType]) {
                    // module type already declared
                    throw new Error(i18n.t(i18n.init_duplicate_module_type, {
                        newModuleFolder: moduleFolder,
                        ...newModules[moduleType]
                    }));
                }

                newModules[moduleType] = {
                    type: moduleType,
                    folder: moduleFolder
                };
            }
            options.modules = newModules;

        } else {
            options.modules = {};
        }
    }

    async execute(destPath, options) { //NOSONAR
        await this.checkPrecondition(destPath, options);

        if (!options.quiet) {
            const message = (options.reinit
                ? i18n.t(i18n.init_reinitializing_project, { destination: options.projectName })
                : i18n.t(i18n.init_initializing_project, { destination: options.projectName }));
            this.reportProgress(message, true);
        }

        await this._removeEmptyPackageJson(destPath);

        // pipeline templates
        if (options.pipeline) {
            await this.fsHelper.copyTemplate('project/pipeline', destPath, options);
        }

        // copy all standard project files
        await this.fsHelper.copyTemplate('project/common', destPath, options);

        // mta template
        if (options.mta) {
            await this.fsHelper.copyTemplate('project/mta', destPath, options);
        }

        // assume vs code as ide if ran from command line
        if (!process.env[Constants.ENV_KEY_CDS_IDE]) {
            await this.fsHelper.copyTemplate('project/vscode', destPath, options);
        }

        // skip samples if not both srv and db are present
        const dbModule = options.modules[Constants.MODULE_TYPE_DB];
        const srvModule = options.modules[Constants.MODULE_TYPE_SRV];
        const copySamples = !options.skipSampleModels && dbModule && srvModule;

        // handle all sub modules
        for (let moduleType of Object.keys(options.modules)) {
            const moduleFolder = options.modules[moduleType].folder;
            const handler = this._getAddHandler(moduleType);
            await handler.stageCopyTemplates(moduleFolder, options);
            await handler.stagePostProcessing(moduleFolder, options);

            // ... and the samples
            if (copySamples) {
                await handler.copySamples(moduleFolder, options);
            }
        }

        if (options.modules[Constants.MODULE_TYPE_SRV] && options.srvTechnology === Constants.SRV_TECHNOLOGY_JAVA) {
            const cloudSdkVersion = await this._getCloudSdkVersion(path.join(destPath, options.modules[Constants.MODULE_TYPE_SRV].folder, 'pom.xml'));
            options.cloudSdkVersion = cloudSdkVersion || MvnArchetypes.ARCHETYPE_VERSION;

            await this.fsHelper.copyTemplate('project/java', destPath, options);
            await this._addIntegrationTests(destPath, copySamples, options);
        }

        await this._stagePostProcessing(options);
    }

    async _addIntegrationTests(destPath, copySamples, options) {
        const integrationTestsPath = path.join(destPath, 'integration-tests');

        const packagePath = options.javaPackage.split('.');
        const javaSrcPath = path.join(integrationTestsPath, 'src', 'test', 'java', ...packagePath);
        const resourcesSrcPath = path.join(integrationTestsPath, 'src', 'test', 'resources');

        await this.fsHelper.copyTemplate('integration-tests/common', integrationTestsPath, options);

        switch (options.odataVersion) {
            case Constants.ODATA_VERSION_V2:
                await this.fsHelper.copyTemplate('integration-tests/odatav2/src/test/resources', resourcesSrcPath, options);
                await this.fsHelper.copyTemplate('integration-tests/odatav2/src/test/java/util', javaSrcPath, options);
                if (copySamples) {
                    await this.fsHelper.copyTemplate('integration-tests/odatav2/src/test/java/samples', javaSrcPath, options);
                }
                break;
            case Constants.ODATA_VERSION_V4:
                await this.fsHelper.copyTemplate('integration-tests/odatav4/src/test/resources', resourcesSrcPath, options);
                await this.fsHelper.copyTemplate('integration-tests/odatav4/src/test/java/util', javaSrcPath, options);
                if (copySamples) {
                    await this.fsHelper.copyTemplate('integration-tests/odatav4/src/test/java/samples', javaSrcPath, options);
                }
                break;
            default:
                throw new Error(`Invalid odata version ${options.odataVersion}`);
        }
    }

    // remove empty package.json and let generator copy template
    async _removeEmptyPackageJson(destPath) {
        const packageJsonPath = path.join(destPath, Constants.FILE_NAME_PACKAGE_JSON);
        if (await this.fsHelper.pathExists(packageJsonPath)) {
            const packageJson = await this.fsHelper.readJSON(packageJsonPath);
            if (Object.keys(packageJson).length === 0) {
                await this.fsHelper.remove(packageJsonPath);
            }
        }
    }

    _getAddHandler(moduleType) {
        switch (moduleType) {
            case Constants.MODULE_TYPE_DB:
                if (!this._dbAddHandler) {
                    this._dbAddHandler = new AddDbHandler(this);
                }
                return this._dbAddHandler;

            case Constants.MODULE_TYPE_SRV:
                if (!this._srvAddHandler) {
                    this._srvAddHandler = new AddSrvHandler(this);
                }
                return this._srvAddHandler;

            default:
                throw new Error(`Unknown type ${moduleType}`);
        }
    }

    async checkPrecondition(destPath, options) {

        if (options.force && !options.quiet) {
            this.logger.warn(i18n.init_using_force);
        }

        const absoluteCwd = path.resolve('.');
        if (!destPath.startsWith(absoluteCwd)) {
            throw new Error(i18n.init_invalid_project_path);
        }

        // with srv java use db hana, else print warning
        if (options.modules[Constants.MODULE_TYPE_SRV]
            && options.modules[Constants.MODULE_TYPE_DB]
            && options.srvTechnology === Constants.SRV_TECHNOLOGY_JAVA
            && options.dbTechnology !== Constants.DB_TECHNOLOGY_HANA) {
            this.reportWarning(i18n.init_srv_java_and_db_hana, !options.quiet);
        }

        if (!options.force) {
            this.validateDestination(destPath);

            if (path.basename(destPath) === 'help') {
                throw new Error(i18n.init_project_name_help_error);
            }
        }

        if (await this.fsHelper.pathExists(destPath)) {
            const folderContent = await this.fsHelper.readdir(destPath);
            if (folderContent.length > 0) {
                options.reinit = true;
            }
        }

        await this._checkModulesPreconditions(options);
    }

    async _checkModulesPreconditions(options) {
        // handle all sub modules
        for (let moduleType of Object.keys(options.modules)) {
            const moduleFolder = options.modules[moduleType].folder;
            const handler = this._getAddHandler(moduleType);
            await handler.checkPrecondition(moduleFolder, options);
        }
    }

    async _stagePostProcessing(options) {
        // root config file processing
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);
        this.reportProgress(i18n.t(i18n.init_updating_dependencies, { packageJsonPath }), options.verbose);
        await this.updateDependencies(packageJsonPath, options);

        if (!options.skipInstall) {
            this.reportProgress(
                i18n.init_running_npm_install,
                options.verbose
            );
            const npmInstallCmd = [
                'npm',
                'install'
                // '--no-package-lock',
                // '--no-shrinkwrap'
            ];

            if (options.debug) {
                npmInstallCmd.push('-dd');
            }

            await ExecHelper.spawnCommand(npmInstallCmd, options.projectRoot, options, this.logger);
        }
    }

    async _getCloudSdkVersion(pomXmlPath) {
        if (await this.fsHelper.pathExists(pomXmlPath)) {
            const pomXml = await this.fsHelper.readFile(pomXmlPath);
            const pom = await XmlHelper.parse(pomXml);

            if (Array.isArray(pom.project.parent)) {
                const sdkEntry = pom.project.parent.find((entry) => {
                    return entry.groupId.includes(Constants.CLOUD_SDK_GROUP_ID);
                });
                if (sdkEntry) {
                    return sdkEntry.version[0];
                }
            }
        }

        return null;
    }
}

module.exports = InitCommand;
