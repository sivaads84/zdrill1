const os = require('os');
const path = require('path');

const Constants = require('./constants');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');
const Logger = require('./helper/logger');
const NpmDependenciesHelper = require('./helper/npm_dependencies_helper');
const OptionsHelper = require('./helper/options_helper');

const defaultLogger = new Logger();
const defaultFsHelper = new FsHelper();

const CONFIG = Object.freeze({
    force: {
        default: false
    },
    quiet: {
        default: false
    },
    verbose: {
        default: false
    },
    debug: {
        default: !!process.env.DEBUG
    }
});

class Command {
    constructor(childConfig = {}, logger = defaultLogger, fsHelper = defaultFsHelper) {
        this._config = { ...CONFIG, ...childConfig };

        this._options = {};
        this._cmdOptions = [];
        this._cmdFlags = [];

        this.logger = logger;
        this.fsHelper = fsHelper;

        // create OPTIONS and FLAGS arrays
        for (let key in this._config) {
            const configEntry = this._config[key];
            const cmdLine = OptionsHelper.generateCmdLine(key);
            if (typeof configEntry.default === 'boolean') {
                this._cmdFlags.push(cmdLine);
            } else {
                this._cmdOptions.push(cmdLine);
            }
        }
    }

    get options() {
        return this._options;
    }

    get cmdOptions() {
        return this._cmdOptions;
    }

    get cmdFlags() {
        return this._cmdFlags;
    }

    run(args, options, cdsEnv) { // NOSONAR
        options = OptionsHelper.convertOptions(options);

        for (let configName in this._config) {
            let configValue = this._config[configName].default;

            this._options[configName] = configValue;
        }

        for (let optionName in options) {
            let optionValue = options[optionName];
            let option = this._config[optionName];

            if (!option) {
                throw new Error(
                    i18n.t(i18n.command_invalid_option, {
                        optionName,
                        optionValue
                    })
                );
            }

            if (typeof optionValue === 'string') {
                optionValue = optionValue.replace(/\s+/g, '').trim();

                if (option.regex) {
                    if (!optionValue.match(option.regex)) {
                        throw new Error(
                            i18n.t(i18n.command_invalid_option_value, {
                                optionName,
                                optionValue
                            })
                        );
                    }
                } else if (option.choices) {
                    optionValue = this._handleChoices(optionName, optionValue);
                }
            }

            this._options[optionName] = optionValue;
        }

        if (this._options.debug) {
            this._options.verbose = true;
            this._options.quiet = false;
        } else {
            if (this._options.verbose) {
                this._options.quiet = false;
            }
        }

        this._optionsProcessing(args, this._options, cdsEnv);
    }

    _handleChoices(optionName, value) {
        const option = this._config[optionName];
        if (!option.multiple) {
            // allow empty value, but revoke comma list
            if (value.includes(',') || (value && !option.choices.includes(value))) {
                throw new Error(i18n.t(i18n.command_invalid_option_value, {
                    optionName,
                    optionValue: value
                }));
            }

            return value;

        } else {
            const values = value.split(',');
            const results = [];
            for (const currentValue of values) {
                const trimmedValue = currentValue.trim();
                if (!option.choices.includes(trimmedValue)) {
                    throw new Error(i18n.t(i18n.command_invalid_option_value, {
                        optionName,
                        optionValue: trimmedValue
                    }));
                }
                results.push(trimmedValue);
            }

            return results;
        }
    }

    async finalize() {
        // print summary
        if (this._options.debug || process.env[Constants.ENV_VAR_GENERATION_LOG]) {
            const touchedFiles = this.fsHelper.getTouchedFiles();

            if (this._options.debug) {
                this.reportProgress();
                this.reportProgress(i18n.command_summary);

                touchedFiles.forEach(file => {
                    this.reportProgress(i18n.t(i18n.command_touched_file, { file }));
                });
            }

            if (process.env[Constants.ENV_VAR_GENERATION_LOG]) {
                const fileList = touchedFiles.join(os.EOL);
                await this.fsHelper.writeFile(
                    process.env[Constants.ENV_VAR_GENERATION_LOG],
                    fileList,
                    true
                );
            }
        }
    }

    _optionsProcessing(args, options, cdsEnv) {
        // arg processing

        options.destination = path.normalize(args[0] || '.');

        options.genFolder =
            (cdsEnv && cdsEnv.build && cdsEnv.build.target) || Constants.DEFAULT_GEN_FOLDER;
    }

    validateDestination(destPath) {
        const segments = destPath.split(/[/\\]/);
        segments.forEach(segment => {
            if (Constants.WINDOWS_FORBIDDEN_FOLDER_NAMES.includes(segment.toUpperCase())) {
                throw new Error(i18n.t(i18n.command_invalid_folder_name, { folderName: segment }));
            }
        });
    }

    reportProgress(message, show) {
        if (show) {
            this.logger.log(message || '');
        }
    }

    reportWarning(message, show) {
        if (show) {
            this.logger.warn(message || '');
        }
    }

    async updateDependencies(packageJsonPath, options) {
        if (await this.fsHelper.pathExists(packageJsonPath)) {
            const packageJsonContent = await this.fsHelper.readFile(packageJsonPath);

            if (packageJsonContent.includes(NpmDependenciesHelper.REPLACE_TOKEN)) {
                const packageJson = JSON.parse(packageJsonContent);
                packageJson.dependencies = await NpmDependenciesHelper.updateDependencies(
                    packageJson.dependencies,
                    options,
                    this.logger
                );
                packageJson.devDependencies = await NpmDependenciesHelper.updateDependencies(
                    packageJson.devDependencies,
                    options,
                    this.logger
                );

                await this.fsHelper.writeJSON(packageJsonPath, packageJson, {
                    spaces: 2
                });
            }
        }
    }

    isWebIDE() {
        return process.env[Constants.ENV_KEY_CDS_IDE] === Constants.ENV_KEY_CDS_IDE_WEBIDE;
    }
}

module.exports = Command;
